• The flat profile gives detailed data on the running times of functions.
• The call graph generated by gprof tells which functions call which functions, and how
many times.

First, compile your code with the –pg option.
gcc -Wall -pg myprog.c
This generates an executable file (it is a.out without the option –o).
• Then, you run the executable with the command-line parameters (if any).
./a.out
This creates a profile-data file with the default name gmon.out.
• Finally, call gprof with the executable file name and the profile-data file. If the data
file has the default name, you can omit it.
gprof ./a.out gmon.out

• A listing of the functions in your program with profiling information.
• The summary for each function shows the contributions of all invocations of the
function.
• % time: The percentage of time spent by the program while it was in that function
(excluding the time spent in other function calls, if any, made from this function).
• Self time: The time spent inside this function (excluding times spent in caller and called
functions). The listing is sorted in the decreasing order of these times.
• Cumulative time: The total self time spent by this function plus the self times of the
functions appearing above this function in the table.
• Calls: The number of times the function is called.
• Average self time per call: This is the self time divided by the number of calls, in s
(seconds), ms (milliseconds), us (microseconds), or ns (nanoseconds).
• Average total time per call: Self time plus the time spent in other function calls made
from this function, again in s, ms, us, or ns.
Systems Programming Laboratory, Spring 2023

Q1)Your boss gives you an executable file secretapp without the source code, and asks you to profile the
application. The program has been compiled by the -pg flag, so gprof can handle the executable. You
run the program, and find that it takes about a second for each run. You know that gprof requires a total
running time of ten seconds (or more) to generate a meaningful profile. But you cannot add a loop to run
the body of the main function ten times. Investigate how you can club together the profiling data of ten
independent runs of secretapp in order to solve your problem
-->
If you cannot add a loop to run the body of the main function ten times, 
you can still obtain a meaningful profile by using gprof on ten independent runs of the executable and then combine the profiling data using the gprofmerge tool.

Here are the steps to follow:

Run the executable with the -pg flag ten times, each time redirecting the output to a separate file. For example:
bash

./secretapp -pg > profile1.out
./secretapp -pg > profile2.out
...
./secretapp -pg > profile10.out
Use gprof on each output file to generate a profile. For example:

gprof secretapp profile1.out > profile1.txt
gprof secretapp profile2.out > profile2.txt
...
gprof secretapp profile10.out > profile10.txt
Use gprofmerge to combine the profiling data from the ten independent runs into a single profile. For example:

gprofmerge profile1.txt profile2.txt ... profile10.txt > merged.txt
Analyze the merged profile using gprof. For example:

gprof secretapp merged.txt
The resulting profile will show the cumulative results of all ten runs, giving you the meaningful profile that you need without modifying the original program.

Q2). Let n be a positive integer. Assume that n > 1. A proper divisor d of n is a divisor of n satisfying
1 < d < n. You write the following program to compute the smallest and the largest proper divisors of all
n in the range 1 < n < N. A prime number n does not have a proper divisor, so we take both the smallest
and the largest proper divisors of n to be 0. Choose N such that the program runs for a few seconds.
int spd ( int n )
{
int d, s;
s = sqrt(n);
for (d = 2; d < s; ++d) {
if (n % d == 0) return d;
}
return 0;
}
int lpd ( int n )
{
int d;
for (d = n / 2; d > 1; --d) {
if (n % d == 0) return d;
}
return 0;
}
int main ()
{
int n, N = ...;
for (n=2; n<=N; ++n) {
spd(n);
lpd(n);
}
}
Using gprof, identify the source(s) of inefficiency in the program. Repair the problem
-->


#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int spd(int n)
{
    int d, s;
    s = sqrt(n);
    for (d = 2; d < s; ++d)
    {
        if (n % d == 0)
            return d;
    }
    return 0;
}

int lpd(int n)
{
    if (spd(n))
        return n / spd(n);
    return 0;
}

int main()
{
    int n, N = 500000;
    for (n = 2; n <= N; ++n)
    {
        printf("%d %d ", spd(n),
               lpd(n));
    }
}

Q3)3. You use gprof to get the call graph of the following C program.
void f1(), f2(), f3();
void f1() { f2(); f3(); }
void f2() { f3(); }
void f3() { }
int main()
{
int x, y, z, i;
scanf("%d%d%d", &x, &y, &z);
for (i=0; i<x; ++i) { f1(); f2(); }
for (i=0; i<y; ++i) { f1(); f3(); }
for (i=0; i<z; ++i) { f2(); f3(); }
}
A part (contiguous) of the output supplied by gprof is given below.
----------------------------------------------------
0.00 0.00 7/19 main [9]
0.00 0.00 12/19 f1 [3]
[2] 0.0 0.00 0.00 19 f2 [2]
0.00 0.00 19/40 f3 [1]
----------------------------------------------------
Derive what values of x, y and z are supplied by the user

-->
5 7 2

Q4)You use gprof to get the call graph of the following C program.
void f ( int n, int x )
{
if ( n > 0 ) f (n - x, x);
}
int main ()
{
int x;
printf("x = "); scanf("%d", &x);
f(100,x);
}
If the following line appears in the gprof output, what is the value of x is supplied by the user? Explain.
[1] 0.0 0.00 0.00 1+12 f [1]

-->
9

Q5)Consider the following mutually recursive functions.
void f ( int n ) { if (n > 0) g(n-1); }
void g ( int n ) { if (n > 0) h(n-2); }
void h ( int n ) { if (n > 0) f(n-3); }
The main() function calls f(100), and does nothing else. Study the call graph supplied by gprof for this
program.

-->

			Call graph


granularity: each sample hit covers 2 byte(s) no time propagated

index % time    self  children    called     name
[1]      0.0    0.00    0.00       1+51      <cycle 1 as a whole> [1]
                0.00    0.00      18             f <cycle 1> [2]
                0.00    0.00      17             g <cycle 1> [3]
                0.00    0.00      17             h <cycle 1> [4]
-----------------------------------------------
                                  17             h <cycle 1> [4]
                0.00    0.00       1/1           main [10]
[2]      0.0    0.00    0.00      18         f <cycle 1> [2]
                                  17             g <cycle 1> [3]
-----------------------------------------------
                                  17             f <cycle 1> [2]
[3]      0.0    0.00    0.00      17         g <cycle 1> [3]
                                  17             h <cycle 1> [4]
-----------------------------------------------
                                  17             g <cycle 1> [3]
[4]      0.0    0.00    0.00      17         h <cycle 1> [4]
                                  17             f <cycle 1> [2]
-----------------------------------------------





