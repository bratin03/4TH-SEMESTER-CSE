The four-stage compilation process:

Preprocessing This involves the processing of the # directives. Examples:
    • The #include’d files are inserted in your code.
    • The #define’d macros are substituted throughout your code.
Compiling
    The input to this process is the preprocessed C file, and the output is an
assembly-language code targeted to the architecture of your machine.
Assembling
    The assembly-language code generated by compiling is converted to a
machine code called the object file. The external functions (like printf and
sqrt) are still undefined.
Linking 
    The object file(s) is/are eventually converted to an executable file in this
process. At this point, the external functions from C runtime library and
other libraries are included in the executable file.
Loading 
    Some functions available in shared (or dynamic) libraries are loaded during
runtime from shared object files.

cpp demo.c > demo.i
gcc -S demo.i //outputs demo.s
as demo.s -o demo.o
The symbols in object files are listed by nm.
gcc demo.o
• If you want these functions to be in your executable, compile with the –static flag
gcc -static demo.o
./a.out

 gcc -Wall staquecheck.c stack.c queue.c
 gcc -Wall -o myapp staquecheck.c stack.c queue.c

 gcc -Wall -c stack.c
 gcc -Wall -c queue.c
 gcc -Wall -o myapp staquecheck.c stack.o queue.o

 You can add to the list of default include directories by the -I option

$ gcc -Wall -c -I. stack.c
$ gcc -Wall -c -I. queue.c
$ gcc -Wall -o myapp -I. staquecheck.c stack.o queue.o

You can avoid the -I flag if you set C_INCLUDE_PATH.
• Multiple directories can be added as a colon-separated list DIR1:DIR2:DIR3:...

 export C_INCLUDE_PATH=".:/home/foobar/include:/opt/users/foobar/include"

 library:

$ gcc -Wall -c stack.c
$ gcc -Wall -c queue.c
$ ar rcs libstaque.a stack.o queue.o

gcc -Wall -L. staquecheck.c -lstaque

$ gcc -Wall -fPIC -c stack.c
$ gcc -Wall -fPIC -c queue.c
$ gcc -shared -o libstaque.so stack.o queue.o

$ export LD_LIBRARY_PATH=/usr/local/lib
or
gcc -L. -Wl,-rpath=. app.c -lnumprn

Macros used as flags
#define MACRONAME Define the macro MACRONAME.
#undef MACRONAME Undefine the macro MACRONAME.
#ifdef MACRONAME If MACRONAME is defined.
#ifndef MACRONAME If MACRONAME is not defined.
#else The beginning of the else block of an #ifdef or an #ifndef.
#endif The end of the conditional code.

gcc -Wall -DMYFLAG macros.c

Q1)Suppose that a C file myfile.c uses a function myfunc() that is defined in a static library libfunc.a.
What new files will be created, if any, if the following command is executed? Assume that the library
path is set correctly.
gcc -lfunc myfile.c -o outfile
-->
No new files will be created from the execution of this command, other than the output executable file outfile.

Q2)An application program mathapp.c needs two libraries libalgebra.so and libgeometry.so. Each
of these libraries uses a library libarithmetic.so. Moreover, libalgebra.so additionally uses
libbasicmath.so. Finally, libarithmetic.so and libbasicmath.so use the standard math library libm.so. 
Assume that the runtime library path is appropriately set so that all these libraries can be
located by the compiler and the runtime linker. Show how you can compile mathapp.c
-->
gcc mathapp.c -o mathapp -lalgebra -lgeometry -larithmetic -lbasicmath -lm

Q3)Two C files file1.c and file2.c are to be compiled to form an executable file outfile. Both the
files use a static library libgraph.a stored in the directory /home/foobar/graph/lib and a static
library libstring.a stored in the directory /home/foobar/strings/lib. To access libgraph.a
and libstring.a properly, the C files also need to include some header files stored in the directories
/home/foobar/graph/include and /home/foobar/strings/include. All the header files are to
be accessed from the C files using #include <...> format. Write a single gcc command to do this.
-->
gcc file1.c file2.c -o outfile -I/home/foobar/graph/include -I/home/foobar/strings/include -L/home/foobar/graph/lib -L/home/foobar/strings/lib -lgraph -lstring

Q4)Repeat the last exercise assuming that the shared libraries libgraph.so and libstring.so are available in the directory mentioned. 
Set LD_LIBRARY_PATH, and then use a single gcc command
-->
export LD_LIBRARY_PATH=/home/foobar/graph/lib: /home/foobar/strings/lib
gcc file1.c file2.c -o outfile -I/home/foobar/graph/include -I/home/foobar/strings/include -L/home/foobar/strings/lib -L/home/foobar/graph/lib -lgraph -lstring

Q5)The shared library libstaque.so prepared as described in the slides is copied to a non-system directory
/home/foobar/personal/lib. The environment variable LD_LIBRARY_PATH is not set to include this
directory. You have an application program dfsbfs.c in the directory /home/foobar/algolab, that
uses the stack and queue functions of the staque library. Figure out what extra compilation-time option
you should supply to gcc so that ldd a.out shows that libstaque.so is available in the directory
/home/foobar/personal/lib and the runtime linker does not need setting the LD_LIBRARY_PATH.
-->
gcc dfsbfs.c -o a.out -L/home/foobar/personal/lib -lstaque -Wl,-rpath=/home/foobar/personal/lib

Q6)You are currently in the directory /home/userx/foobar. This directory contains three subdirectories
include, foo, and bar. The subdirectory include contains three header files common.h, foo.h and
bar.h. The subdirectory foo contains three source files foo1.c, foo2.c, and foo3.c, whereas the subdirectory bar contains two source files bar1.c and bar2.c. 
The foo source files require the header files
common.h and foo.h, whereas the bar source files require the header files common.h and bar.h. The
required header files are included in the source file in the format #include "../include/...". The
five source files are to compiled to a single foobar library. Describe how you can do this in the following
two cases: (i) you want a static library libfoobar.a, (ii) you want a dynamic library libfoobar.so.
These libraries should be built in your current directory /home/userx/foobar.
-->

gcc -c -I./include foo/foo1.c foo/foo2.c foo/foo3.c bar/bar1.c bar/bar2.c
ar rcs libfoobar.a foo1.o foo2.o foo3.o bar1.o bar2.o

gcc -c -fPIC -I./include foo/foo1.c foo/foo2.c foo/foo3.c bar/bar1.c bar/bar2.c
gcc -shared -o libfoobar.so foo1.o foo2.o foo3.o bar1.o bar2.o

Q7). A number-theory library and application programs using that library need an array of the primes < 20.
So you plan to use an int array storing these numbers in a header file for the library. However, header
files are not the right place for declaring global variables and arrays. Figure out what problem(s) you face
if you have the following line in the header file. What is the reason behind the problem(s)?
int SMALLPRIMES = { 2, 3, 5, 7, 11, 13, 17, 19 };
How can you overcome the problem(s)? You need to have this array in the header file both during the
compilation of the library and during the compilation of the application programs that use the library
-->
The problem with having the line int SMALLPRIMES = { 2, 3, 5, 7, 11, 13, 17, 19 }; 
in the header file is that each source file that includes this header file will create its own copy of the SMALLPRIMES array, 
leading to multiple definitions of the same symbol during linking. This violates the One Definition Rule (ODR) of C++.

To overcome this problem, we can declare the array in the header file as extern int SMALLPRIMES[];, 
which tells the compiler that SMALLPRIMES is defined somewhere else and it is not the current source file's responsibility to provide a definition for it. 
Then, we can define the array in one of the source files of the library or the application program that uses the library. 
For example, we can add the following line to one of the source files:


int SMALLPRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 };
This ensures that there is only one definition of SMALLPRIMES in the entire program, satisfying the ODR.

Q8). Consider the following program fragment.
unsigned short s;
int i, j;
scanf("%d%d", &i, &j);
s = i / j;
printf("%hu\n", s);
There is an obvious problem with this program. Find it, and show the gcc compilation options such that
(i) gcc will only warn about the problem during compilation,
(ii) gcc will give an error and not compile the program.
-->
The problem with this program is that the result of the integer division i / j may exceed the maximum value that can be stored in an unsigned short. 
This can result in an incorrect value being stored in s.

To address this problem, we can add a check to ensure that i is less than or equal to the maximum value that can be safely divided by j. 
We can also modify the program to use a float or double data type for the division.

To generate a warning during compilation, we can use the -Wconversion flag, which enables warnings for implicit conversions that may change a value:


gcc -Wconversion program.c -o program
To generate an error and prevent compilation, we can use the -Werror flag, which treats all warnings as errors:


gcc -Werror program.c -o program
Note that using -Werror will cause any warnings, including those not related to the specific problem in the program, 
to be treated as errors and prevent compilation. It is therefore important to ensure that the code is warning-free before using -Werror.

Q9)Suppose that your C program has the following diagnostic printf statements.
printf("++: ...");
printf("+: ...");
printf("++: ...");
printf("+++: ...");
The printf starting with a single + is always to be printed. The printf’s starting with only two + are printed
if the user wants verbose output. The printf’s starting with two and three + are printed if the user wants
very verbose output. The user decides during compilation time whether (s)he uses the normal or the
verbose or the very verbose mode. Modify the above code (without deleting any printf and without using
any extra variables) so that the user can select the printing mode using appropriate compilation options.
Show both the modified code and the compilation options.

-->#include <stdio.h>

#ifndef VERBOSE
#define VERBOSE 0
#endif

#ifndef VERY_VERBOSE
#define VERY_VERBOSE 0
#endif

int main() {
    printf("+: ...\n");
    if (VERBOSE) {
        printf("++: ...\n");
    }
    if (VERY_VERBOSE) {
        printf("++: ...\n");
        printf("+++: ...\n");
    }
    printf("++: ...\n");
    return 0;
}

gcc -o program program.c

gcc -o program program.c -DVERBOSE=1

gcc -o program program.c -DVERY_VERBOSE=1




Q10). Consider the following C program with undefined symbols N and A.
int main ()
{
int cnt = N, i, arr[N] = A;
for (i=0; i<cnt; ++i) printf("%d\n", arr[i]);
}
How can you define N and A as macros during compilation so that gcc successfully compiles the file?
-->
gcc -DN=5 -DA='{1, 2, 3, 4, 5}' program.c -o program



